<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DREAM RPG</title>
    <style>
        @font-face {
            font-family: 'rock';
            src: url('https://raw.githubusercontent.com/njwon/portfolio/refs/heads/main/projects/textrpg/font/DeathMohawk_PERSONAL_USE_ONLY.otf') format('opentype');
        }


        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1d1d1d;
            color: #eee;
            display: flex;
            justify-content: center;
            align-items: center;
            max-height: 1250px;
            margin: 0;
            overflow-x: hidden;
            -ms-overflow-style: none;
            width: 100vw;
            height: 100vh;
            animation-duration: 0.1s;
            animation-iteration-count: infinite;
            animation-name: textflicker;
            text-shadow: 0.06rem 0 0.06rem #ea36af, -0.125rem 0 0.06rem #75fa69;
            animation-direction: alternate;
            filter: blur(0.4px);
        }

        ::-webkit-scrollbar {
            display: none;
        }

        @keyframes textflicker {
            from {
                text-shadow: 1px 0 0 #ea36af, -2px 0 0 #75fa69;
            }

            to {
                text-shadow: 2px 0.5px 2px #ea36af, -1px -0.5px 2px #75fa69;
            }
        }

        .noise {
            content: '';
            z-index: 1;
            height: 180%;
            left: -40%;
            top: -40%;
            width: 180%;
            overflow: hidden;
            position: fixed;
            max-height: 150vh;
            pointer-events: none;
            will-change: transform;
            -webkit-transition: opacity 0.6s ease-out;
            transition: opacity 0.6s ease-out;
            -webkit-animation: noiseAnimation 1s steps(4) infinite;
            animation: noiseAnimation 1s steps(4) infinite;
            background-image: url('https://raw.githubusercontent.com/njwon/portfolio/refs/heads/main/img/noise/noise2.webp');
            filter: blur(3px);
            /* opacity: 0.3; */
        }

        @-webkit-keyframes noiseAnimation {
            0% {
                -webkit-transform: translate(0, 0);
                transform: translate(0, 0);
            }

            10% {
                -webkit-transform: translate(-5%, -0);
                transform: translate(-5%, 0);
            }

            20% {
                -webkit-transform: translate(-10%, 0);
                transform: translate(-10%, 0);
            }

            30% {
                -webkit-transform: translate(5%, 0);
                transform: translate(5%, 0);
            }

            40% {
                -webkit-transform: translate(-5%, 0);
                transform: translate(-5%, 0);
            }

            50% {
                -webkit-transform: translate(-10%, 0);
                transform: translate(-10%, 0);
            }

            60% {
                -webkit-transform: translate(15%, 0);
                transform: translate(15%, 0);
            }

            70% {
                -webkit-transform: translate(0, 0);
                transform: translate(0, 0);
            }

            80% {
                -webkit-transform: translate(-15%, 0);
                transform: translate(-15%, 0);
            }

            90% {
                -webkit-transform: translate(10%, 0);
                transform: translate(10%, 0);
            }

            100% {
                -webkit-transform: translate(5%, 0);
                transform: translate(5%, 0);
            }
        }

        @keyframes noiseAnimation {
            0% {
                -webkit-transform: translate(0, 0);
                transform: translate(0, 0);
            }

            10% {
                -webkit-transform: translate(-5%, -0);
                transform: translate(-5%, 0);
            }

            20% {
                -webkit-transform: translate(-10%, 0);
                transform: translate(-10%, 0);
            }

            30% {
                -webkit-transform: translate(5%, 0);
                transform: translate(5%, 0);
            }

            40% {
                -webkit-transform: translate(-5%, 0);
                transform: translate(-5%, 0);
            }

            50% {
                -webkit-transform: translate(-10%, 0);
                transform: translate(-10%, 0);
            }

            60% {
                -webkit-transform: translate(15%, 0);
                transform: translate(15%, 0);
            }

            70% {
                -webkit-transform: translate(0, 0);
                transform: translate(0, 0);
            }

            80% {
                -webkit-transform: translate(-15%, 0);
                transform: translate(-15%, 0);
            }

            90% {
                -webkit-transform: translate(10%, 0);
                transform: translate(10%, 0);
            }

            100% {
                -webkit-transform: translate(5%, 0);
                transform: translate(5%, 0);
            }
        }

        #start-container,
        #game-container {
            width: 90vw;
            height: 100vh
        }

        .title {
            text-align: center;
            /* color: #4CAF50; */
            letter-spacing: 4px;
            font-family: 'rock', sans-serif;
            font-size: 100px;
        }

        .input-group {
            margin-bottom: 1.5rem;
        }

        label {
            display: block;
            margin-bottom: 0.5rem;
            color: #eee;
        }

        input[type="text"],
        input[type="password"],
        textarea {
            width: 100%;
            padding: 0.8rem;
            border: 0.5px dashed #eee;
            background-color: #11111100;
            color: #eee;
            border-radius: 4px;
            box-sizing: border-box;
            animation-duration: 0.1s;
            animation-iteration-count: infinite;
            animation-name: boxflicker;
            text-shadow: 0.06rem 0 0.06rem #ea36af, -0.125rem 0 0.06rem #75fa69;
            animation-direction: alternate;
        }

        @keyframes boxflicker {
            0% {
                box-shadow: 1px 0 0 #ea36af, -2px 0 0 #75fa69;
                text-shadow: 1px 0 0 #ea36af, -2px 0 0 #75fa69;
            }

            25% {
                box-shadow: inset 1px 0 0 #ea36af, inset -2px 0 0 #75fa69;
                text-shadow: 2px 0.5px 2px #ea36af, -1px -0.5px 2px #75fa69;
            }


            50% {
                box-shadow: 2px 0.5px 2px #ea36af, -1px -0.5px 2px #75fa69;
                text-shadow: 1px 0 0 #ea36af, -2px 0 0 #75fa69;
            }

            100% {
                box-shadow: inset 2px 0.5px 2px #ea36af, inset -1px -0.5px 2px #75fa69;
                text-shadow: 2px 0.5px 2px #ea36af, -1px -0.5px 2px #75fa69;
            }
        }

        textarea {
            resize: none;
            min-height: 100px;
        }

        input[type="radio"] {
            display: none;
        }

        button,
        .radio-label {
            padding: 1rem;
            background-color: #eee;
            color: #111;
            border: none;
            border-radius: 4px;
            font-size: 1.1rem;
            cursor: pointer;
            transition: background-color 0.3s;
            animation-duration: 0.1s;
            animation-iteration-count: infinite;
            animation-name: boxflicker;
            text-shadow: 0.06rem 0 0.06rem #ea36af, -0.125rem 0 0.06rem #75fa69;
            animation-direction: alternate;
        }

        .ai-name {
            display: flex;
            justify-content: space-evenly;
            flex-wrap: wrap;
            flex-direction: row;
        }

        .radio-label {
            font-size: 15px;
            text-align: center;
            width: 190px;
        }

        .radio-label:has(input[type="radio"]:checked) {
            background-color: #ffffff00;
            color: #fff;
        }

        button {
            width: 100%;
        }

        button:hover {
            background-color: #9b9b9b;
        }

        button:disabled {
            background-color: #9b9b9b;
            cursor: not-allowed;
        }

        #result-container {
            margin-top: 2rem;
            padding: 1.5rem;
            border-radius: 4px;
            white-space: pre-wrap;
            /* To preserve formatting from the AI */
            line-height: 1.6;
        }

        .loading {
            text-align: center;
            font-style: italic;
        }

        .start-battle {
            padding-bottom: 100px;
        }
    </style>
</head>

<body>

    <div class="noise"></div>
    <div id="start-container">
        <div class="title">&lt;DREAMRPG&gt;</div>

        <div class="input-group">
            <label for="char-name">캐릭터 이름</label>
            <input type="text" id="char-name">
        </div>

        <div class="input-group">
            <label for="char-setting">캐릭터 설정</label>
            <textarea maxlength="200" rows="4" cols="50" id="char-setting"></textarea>
        </div>


        <div class="input-group">
            <label for="ai-name">사고 방식 선택</label>
            <div class="ai-name">
                <label for="auto" class="radio-label">
                    <input type="radio" id="auto" name="models" value="auto" checked />
                    자동(기본)</label>
                <label for="2.5-flash" class="radio-label">
                    <input type="radio" id="2.5-flash" name="models" value="gemini-2.5-flash" />
                    기본 대뇌
                </label>

                <label for="2.0-flash" class="radio-label">
                    <input type="radio" id="2.0-flash" name="models" value="gemini-2.0-flash" />
                    진화가 덜 된 기본 대뇌
                </label>
                <label for="2.5-pro" class="radio-label">
                    <input type="radio" id="2.5-pro" name="models" value="gemini-2.5-pro" />
                    똑똑하지만 느린 대뇌
                </label>
                <label for="2.5-flash-lite" class="radio-label">
                    <input type="radio" id="2.5-flash-lite" name="models" value="gemini-2.5-flash-lite" />
                    빠른 금수 대뇌
                </label>
                <label for="2.0-flash-lite" class="radio-label">
                    <input type="radio" id="2.0-flash-lite" name="models" value="gemini-2.0-flash-lite" />
                    우둔한 빠른 금수 대뇌
                </label>
            </div>
        </div>
        <button id="start-battle">몽상 시작!</button>
        <br><br><br>
    </div>
    <div id="game-container" style="display: none;">
        <div class="title">TEXTRPG</div>

        <div class="input-group">
            <div id="playerState"></div>
        </div>

    </div>

    <!-- Google AI SDK -->
    <!-- const prompt = {`
당신은 텍스트 RPG의 게임 마스터입니다. 사용자가 만든 캐릭터로 마왕과의 전투를 진행해주세요.

# 캐릭터 정보
- 이름: ${charName}
- 설정: ${charSetting}

# 상대
- 이름: 마왕
- 능력치: ATK 100, HP 100, MP 100

# 임무
1. 위 캐릭터 정보와 설정을 바탕으로, 마왕과의 전투 과정을 흥미진진한 단편 소설처럼 묘사해주세요.
2. 전투의 결과(승리 또는 패배)를 결정해야 합니다. 캐릭터의 설정이 강력하다면 승리할 확률이 높고, 설정이 평범하다면 패배할 확률이 높습니다. 창의적이고 설득력 있는 결말을 만들어주세요.
3. 전투 묘사 후, 결과를 명확하게 표시하고, 왜 그런 결과가 나왔는지 캐릭터의 설정과 연관지어 이유를 설명해주세요.

# 출력 형식 (이 형식을 반드시 지켜주세요)
((소괄호 안에 전투 과정을 소설처럼 서술))
{[승리/패배]}
[(대괄호 안에 결과에 대한 이유를 서술)]
                `} -->
    <script type="module">
        import { GoogleGenerativeAI } from "https://esm.run/@google/generative-ai";

        const apikey = 'AIzaSyAaDuZjDxxH0KKv1m3jBWSbp6N2MLZOy3c';
        const startButton = document.getElementById('start-battle');
        const charNameInput = document.getElementById('char-name');
        const charSettingInput = document.getElementById('char-setting');
        const checkedModelInput = document.querySelector('input[name="models"]:checked');
        const startContainer = document.getElementById('start-container');
        const gameContainer = document.getElementById('game-container');
        const playerStateDiv = document.getElementById('playerState');

        let startPlay;
        let selectValue;
        let game;
        let player;
        let playerState = [];

        class Player {
            constructor(name, fiction, hp, atk, plausible, ability) {
                this.name = name;
                this.fiction = fiction;
                this.hp = hp;
                this.atk = atk;
                this.plausible = plausible;
                this.ability = ability.ability;
                this.abilityAtk = ability.abilityAtk;
                this.abilityEffect = ability.abilityEffect;
            }

            changeState() {
                playerStateDiv.innerHTML = `
                    이름: ${this.name} <br>
                    수식어: ${this.fiction} <br>
                    개연성: ${this.plausible} <br>
                    HP: ${this.hp} <br>
                    ATK: ${this.atk} <br>
                    능력: ${this.ability} <br>
                    능력 공격력: ${this.abilityAtk} <br>
                    능력 효과: ${this.abilityEffect}
                `;
            }
        }

        class Game {
            constructor(name, setting) {
                this.charName = name.value.trim();
                this.charSetting = setting.value.trim();
                this.isRunning = false;
                this.prompt;
                this.genAI;
                this.model;
                this.result;
                this.response;
                this.jsonText;
                this.text;
                this.playerState = [];
            }

            prompt() {
                this.prompt = [`
                당신은 텍스트 RPG의 게임 마스터이자, 캐릭터 생성 심사관입니다. 입니다. 사용자가 만든 캐릭터로 능력치를 설정해주세요.
                
                # 캐릭터 정보
                - 이름: ${this.charName}
                - 설정: ${this.charSetting}
                
                # 능력치 종류
                - 공격: 적을 공격할 때 적의 피가 주는 수치. 제한 없음.
                - 체력: 모두 소진되면 사망하게 되는 수치. 제한 없음.
                - 개연성: 캐릭터의 개연성 수치. 100까지 있습니다.
                - 수식어: 캐릭터의 설정을 짧게 요약한 수식어.
                - 능력: 캐릭터의 회심의 일격, 이른바 필살기. 단 하나의 능력만 가질 수 있다.
                
                # 임무
                1. 위 캐릭터 정보와 설정을 바탕으로, 공격과 체력을 정해주세요.
                2. 위 캐릭터 정보와 설정에 따라 옆 예시의 형식을 참고해 설정을 한 문장으로 요약해 수식어를 만들어 주세요. (예) 한국의 고등학생, 창조신, 바다의 신, 지옥의 악마, 귀여운 강아지)
                3. 플레이어가 만든 캐릭터 이름과 설정을 보고, 다음 조건에 따라 캐릭터의 "개연성 점수"를 0~100 사이에서 평가하세요.( 현실적이고 설득력 있는 설정일수록 낮은 점수를 줍니다., 너무 과장되거나 전지전능한 설정일수록 높은 점수를 줍니다., "강력하지만 합리적인 약점"이 있으면 감산점을 줍니다.)
                4. 위 캐릭터 정보와 설정에 따라 능력을 객관적으로 정해주세요. 능력은 능력명, 공격력, 효과를 한번에 같이 서술해야합니다. (단, 효과를 서술할 때 문장에는 문자열과 공백만 존재해야 함.)
                
                # 출력 형식 (출력은 JSON 형태로 하여야 합니다. 이 형식을 반드시 지켜주세요. 밑 형식과 아래 예시의 형식 참고 단, 아래 형식을 벗어난 모든 숫자, 문자는 출력하지 말아야합니다.)
                    -형식-
                    {
                    "hp": 체력 수치를 숫자만 서술,
                    "atk": 공격력 수치를 숫자만 서술,
                    "plausible": 개연성 수치를 숫자만 서술,
                    "fiction": 수식어를 텍스트로 서술,
                    "abilityStats": {
                        "ability": 능력명을 텍스트로 서술,
                        "abilityAtk": 공격력 수치를 숫자만 서술,
                        "abilityEffect": 효과을 텍스트로 서술
                        }
                    }
                    
                    -예시-
                    {
                    "hp": 40,
                    "atk": 30,
                    "plausible": 5,
                    "fiction": "평범한 고등학생",
                    "abilityStats": {
                        "ability": "불꽃필기",
                        "abilityAtk": 60,
                        "abilityEffect": "미친듯한 집념으로 필기한다. 적에게 불꽃의 환상이 보인다."
                        }
                    }

                만약, 임무를 수행할 수 없을 정도로 주어진 정보가 훼손되거나 이상하다면, "001"라는 텍스트만 출력할 것.
                `, `
                
                `];
            }

            restoreBtn() {
                startButton.textContent = '몽상 시작!';
                startButton.style.backgroundColor = '#eee';
            }

            selectAi() {
                if (selectValue == 'auto') {
                    try {
                        this.model = this.genAI.getGenerativeModel({ model: "gemini-2.5-flash" });
                    } catch {
                        try {
                            this.model = this.genAI.getGenerativeModel({ model: "gemini-2.0-flash" });
                        } catch {
                            try {
                                this.model = this.genAI.getGenerativeModel({ model: "gemini-2.5-pro" });
                            } catch {
                                try {
                                    this.model = this.genAI.getGenerativeModel({ model: "gemini-2.5-flash-lite" });
                                } catch {
                                    this.model = this.genAI.getGenerativeModel({ model: "gemini-2.0-flash-lite" });
                                }
                            }
                        }
                    }
                } else if (selectValue) {
                    this.model = this.genAI.getGenerativeModel({ model: selectValue });
                }
            }

            async sendToAi() {
                if (this.isRunning) return 0;
                if (!this.charName || !this.charSetting) {
                    alert('캐릭터 이름과 설정을 모두 입력해주세요.');
                    return;
                }

                this.isRunning = true;
                startButton.textContent = '대뇌 피질 열일 중..';
                startButton.disabled = true;

                try {
                    this.genAI = new GoogleGenerativeAI(apikey);
                    await this.selectAi();
                    this.result = await this.model.generateContent(this.prompt[0]);
                    this.response = await this.result.response.text();
                    if (this.response != "001") {
                        this.jsonText = this.response.match(/\{[\s\S]*\}/);
                        this.json = JSON.parse(this.jsonText);
                    }
                    try {
                        console.log(JSON.stringify(this.json, null, 2));
                        this.playerState[0] = this.json.fiction; // 설정
                        this.playerState[1] = this.json.hp; // 체력
                        this.playerState[2] = this.json.atk; // 공격력
                        this.playerState[3] = this.json.plausible; // 개연성
                        this.playerState[4] = this.json.abilityStats; // 능력
                    } catch (error) {
                        if (this.response == "001") {
                            alert('주어진 정보가 충분치 않거나 이해할 수 없습니다. 캐릭터 정보를 다시 입력해주세요.');
                        } else if (selectValue == 'auto') {
                            alert('모든 모델이 작동하지 않아 자동을 사용할 수 없습니다. 잠시 후에 다시 이용하여 주세요.');
                        } else {
                            alert('다른 모델로 다시 시도해주세요. 만약 모든 모델을 시도하였다면 잠시 후에 다시 이용하여 주세요.');
                        }
                    }
                    console.log(this.playerState);
                    return [this.playerState[0], this.playerState[1], this.playerState[2], this.playerState[3], this.playerState[4]];
                } catch (error) {
                    if (error)
                        console.log("Error:", error);
                } finally {
                    this.isRunning = false;
                    startButton.disabled = false;
                    startButton.textContent = '전투 시작!';
                }
            }

        }

        startButton.addEventListener('click', async () => {
            selectValue = checkedModelInput?.value;
            game = new Game(charNameInput, charSettingInput);
            game.prompt();
            playerState = await game.sendToAi();
            player = new Player(charNameInput.value, playerState[0], playerState[1], playerState[2], playerState[3], playerState[4]);
            startButton.id = 'start-play';
            startPlay = document.getElementById('start-play');
            startPlay.addEventListener('click', () => {
                startContainer.style.display = 'none';
                gameContainer.style.display = 'block';
                player.changeState();
            });
        });
    </script>
</body>

</html>
